# 概述

根据通讯录中的信息选出哈希表的键值姓名、手机号。对于给定的关键码集合，选择一个简单且地址分布比较均匀的哈希函数，避免或尽量减少冲突。在进行了大量的测试之后，发现DJB哈希函数的性能最优，因此程序最终采用了DJB哈希函数。由于开散列方法优于闭散列方法，因此解决冲突的方法选择了开散列法，即链地址法。为了节省存储空间，最终将两张分离的哈希表整合为一种类似于稀疏矩阵的结构，内存空间节省了一半。测试结果表明，经过以上的几次优化，哈希表的性能获得了很大的性能提升。

#	总体设计

## 设计思路

![img1](http://p1.bpimg.com/567571/c8db2910162d0567.png)

在我们所设计的哈希通讯录中，联系人信息包括姓名，年龄，电话号码，性别，班级，而在这些信息中姓名，电话号码最容易标识某个联系人，因此我选择了电话号码和姓名作为哈希表的键值。
在程序设计的初步我设计了一个比较简单的哈希函数。对于手机号的编码，我将手机号划分为三部分，如下图所示：

![img2](http://p1.bpimg.com/567571/0c962c1532ffcdc5.png)

我将区号中的后两位分别赋予权值100000和10000，地区编码的中间两位赋予权值1000和100，用户号码的中间两位赋予权值10和1。最后求这些选定的数字与权值的乘积之和，得到的值即为我们所要的手机号哈希值。对于姓名的编码，我将每个汉字所对应的编码值全部相加，并与字符串的长度求和，得到的值即为姓名的哈希值。但是这样的哈希函数并不能得到最好的搜索效率，因此在后期我对哈希函数进行了修改，具体说明详见“7调试与测试”部分。
在确定处理哈希表处理冲突的方式方面我参考了表格4-1，如下图所示：
从表中可以看出，开散列法由于闭散列方法；在散列函数中，用除留余数法作列函数优于其他类型的散列函数，最差的是折叠法。当装载因子α较高时，除留余数法的平均搜索次数最小。基于此，我的散列函数选择了除留余数法，处理冲突的方式为开散列方法，即链地址方法。

![t1](http://p1.bpimg.com/567571/89bec5b9ff6bb536.png)

根据选取的键值，我创建了两张哈希表，分别是以姓名为键值的哈希表和以手机号为键值的哈希表。存储结构暂时以单链表结构存储，在“7调试与测试”部分我会进一步优化。另外，我在这里只实现了哈希表基本的操作，分别为插入、搜索、删除。

## 哈希表原理图

![img3](http://i1.piimg.com/567571/029c09a7eeda3adf.png)

上图以姓名为例，显示了哈希表的基本原理。

## 哈希地址的计算

当执行插入、搜索或者删除操作时，首先都会调用地址编码函数Encode，他的参数为string类型的n，返回类型为unsigned int类型的hash值。该函数会根据传进来的参数调用不同的哈希函数，从而计算相应键值的hash值。
最终这些插入、搜索或者删除操作会将Encode返回的hash值对divisor进行整数除法取余运算得到相应键值的哈希地址。如下图4-2为哈希图的产生过程。

![img4](http://p1.bpimg.com/567571/e3dccad928442f12.png)


# 优化

## 哈希函数的优化

哈希函数在哈希表中起着至关重要的作用，因此要想设计一个性能良好的哈希表，必须选取一个好的哈希函数。
最初我针对姓名和手机号设计了一个简易的哈希函数（图中MYHASH），但是搜索效率并不是很高，尤其是对于姓名的搜索，平均搜索长度（ASL）高达509。
为了提高搜索效率，我通过查找资料，找到了几个性能相对较好的哈希函数（分别为DJBHASH、PJWHASH、DEKHASH、SDBHASH、ELFHASH），并对它们逐个进行了性能测试，如下图
从下面两图表中，我们不难发现，程序通过DJK哈希函数产生哈希值可以获得最快的搜索速度，对于手机号的搜索仅仅需要O(1)的时间，同时它的平均搜索长度（ASL）也最短，可以在搜索时产生最少的冲突。另外，从图4中我们也可以看出DJB哈希函数相对稳定。因此，最终我采用了DJB作为哈希表中的哈希函数。

![hist](http://p1.bpimg.com/567571/a895340cbf5ba9b8.png)

![zigzag](http://p1.bqimg.com/567571/c6b78dcc25bf34c6.png)

这个算法是Daniel J.Bernstein 教授发明的，是目前公布的最有效的哈希函数。下面我简单描述一下该算法的流程：
1. 首先hash值初始值位5381；
1.	将hash值左移5位得到新的hash值，再与hash值和字符串的第i位求和；
3.	重复2中的步骤，直到遍历完字符串中的所有字符；
4.	此时即得到最终hash值。

## 哈希表的优化

哈希表是一种以空间为代价换取时间的一种存储方式，因此创建哈希表需要大量的内存空间。但是通过对之前创建的哈希表的结构分析，我发现有些空间 是完全可以节省的，于是我采取了下述一种正交链表的存储方式。改进之后，内存空间节省了一半。另外，为了提高删除速度，我将单链表结构改为了双向链表结构（图中未画出）。

![hashtable](http://i1.piimg.com/567571/c037108d025863fb.png)
